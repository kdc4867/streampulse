# StreamPulse 시스템 아키텍처 - 층계 비유

## 🏢 건물 구조로 이해하는 시스템

```
┌─────────────────────────────────────────┐
│  10층: 사용자 브라우저 (외부 세계)      │
│  - Chrome, Safari, Firefox              │
│  - http://EC2_IP:80 접속                │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  9층: EC2 서버 (건물 입구)              │
│  - AWS 클라우드 서버                    │
│  - 포트 80, 8081, 8501, 8000 등         │
│  - 보안 그룹으로 접근 제어              │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  8층: Docker Compose (건물 관리실)      │
│  - 모든 층을 관리하는 관리자            │
│  - docker compose up/down              │
│  - 서비스 간 연결 설정                  │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  7층: Nginx (안내 데스크)               │
│  - 방문자 안내 및 길 안내                │
│  - 포트 80에서 모든 요청 접수           │
│  - /api/* → 6층으로 안내                │
│  - / → 5층으로 안내                     │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  6층: API 서버 (FastAPI + Uvicorn)      │
│  - 컨테이너 내부: 포트 8080             │
│  - EC2에서 접근: 포트 8081              │
│  - 데이터 요청 처리                      │
│  - DuckDB/Postgres와 통신               │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  5층: 프론트엔드 (React + Vite)          │
│  - 개발: Vite 개발 서버 (포트 5173)     │
│  - 프로덕션: Nginx가 빌드된 파일 제공   │
│  - 사용자 인터페이스                    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  4층: Agent 서비스 (AI 분석)            │
│  - Agent API: 포트 8000                 │
│  - Agent Worker: 백그라운드 작업        │
│  - LangGraph 워크플로우                 │
│  - OpenAI API 호출                      │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  3층: 데이터 처리 서비스                │
│  - Collector: 데이터 수집 (5분마다)     │
│  - Detector: 급등 감지 (5분마다)        │
│  - 내부 작업만 수행 (외부 포트 없음)    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  2층: 캐시 서버 (Redis)                 │
│  - 포트 6379                            │
│  - 중복 분석 방지                       │
│  - 빠른 데이터 조회                    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  1층: 데이터 저장소 (지하 창고)          │
│  - Postgres: 포트 5432 (메타데이터)     │
│  - DuckDB: 파일 시스템 (시계열 데이터)  │
│  - 모든 데이터의 최종 저장소            │
└─────────────────────────────────────────┘
```

---

## 📖 층별 상세 설명

### 10층: 사용자 브라우저 (외부 세계)
**역할**: 건물 밖에서 건물을 바라보는 사람들

- 사용자가 브라우저로 `http://EC2_IP:80` 접속
- React 앱을 받아서 화면에 표시
- API 요청을 보내고 응답을 받음

**비유**: 건물 밖에서 건물을 보는 사람

---

### 9층: EC2 서버 (건물 입구)
**역할**: 건물 자체, 모든 층이 있는 물리적 공간

- AWS 클라우드 서버
- 모든 서비스가 여기서 실행됨
- 포트들이 여기서 열림:
  - 80: 웹 접근
  - 8081: API 직접 접근
  - 8501: Streamlit 대시보드
  - 8000: Agent API
  - 5432: Postgres
  - 6379: Redis

**비유**: 건물 자체, 모든 층이 있는 건물

---

### 8층: Docker Compose (건물 관리실)
**역할**: 건물 관리자, 모든 층을 관리

- 모든 서비스를 하나의 명령어로 시작/중지
- 서비스 간 연결 설정
- 각 층(컨테이너)의 생명주기 관리

**비유**: 건물 관리실에서 모든 층의 전기, 수도, 엘리베이터를 관리

**명령어**:
```bash
docker compose up -d    # 모든 층에 전기 켜기
docker compose down     # 모든 층에 전기 끄기
docker compose ps       # 각 층 상태 확인
```

---

### 7층: Nginx (안내 데스크)
**역할**: 건물 입구의 안내 데스크, 방문자 안내

- 포트 80에서 모든 요청을 받음
- 요청 종류에 따라 안내:
  - `/api/*` 요청 → 6층(API 서버)로 안내
  - `/` 요청 → 5층(프론트엔드)로 안내

**비유**: 건물 입구에서 "API는 6층, 웹은 5층으로 가세요"라고 안내

**nginx.conf 설정**:
```nginx
location /api/ {
  proxy_pass http://api:8080;  # 6층으로 안내
}

location / {
  try_files $uri /index.html;  # 5층 파일 제공
}
```

---

### 6층: API 서버 (FastAPI + Uvicorn)
**역할**: 데이터 요청 처리 담당

- 컨테이너 내부: 포트 8080에서 실행
- EC2에서 접근: 포트 8081로 매핑
- DuckDB/Postgres에서 데이터 조회
- JSON 응답 반환

**비유**: 고객 서비스 센터, 데이터 요청을 처리하고 답변 제공

**포트 매핑**:
```
EC2:8081 → Docker 포트 매핑 → 컨테이너:8080 → FastAPI
```

**Docker 네트워크 내부**:
```
Nginx (7층) → api:8080 → API 서버 (6층)
```

---

### 5층: 프론트엔드 (React + Vite)
**역할**: 사용자가 보는 화면

**개발 환경**:
- Vite 개발 서버가 5173 포트에서 실행
- 코드 변경 시 자동 새로고침
- `/api` 요청을 `localhost:8081`로 프록시

**프로덕션 환경**:
- Vite가 React 앱을 빌드
- 빌드된 파일을 Nginx가 제공
- 사용자는 Nginx를 통해 React 앱을 받음

**비유**: 
- 개발: 공사 중인 층 (Vite 개발 서버)
- 프로덕션: 완성된 층 (빌드된 파일을 Nginx가 제공)

---

### 4층: Agent 서비스 (AI 분석)
**역할**: AI 분석 전문가

**Agent API (포트 8000)**:
- 외부에서 직접 호출 가능
- AI 분석 요청 처리

**Agent Worker**:
- 백그라운드에서 자동으로 작업
- Postgres의 PENDING 이벤트를 자동 분석
- 포트 없음 (내부 작업만)

**비유**: 
- Agent API: 상담실 (외부 접근 가능)
- Agent Worker: 사무실 (내부 작업만)

---

### 3층: 데이터 처리 서비스
**역할**: 데이터 수집 및 분석 작업

**Collector**:
- 5분마다 SOOP/CHZZK에서 데이터 수집
- DuckDB에 저장
- 포트 없음 (내부 작업만)

**Detector**:
- 5분마다 DuckDB 분석
- 급등 감지
- Postgres에 이벤트 기록
- 포트 없음 (내부 작업만)

**비유**: 공장 작업실, 자동으로 작업만 수행 (외부 접근 불가)

---

### 2층: 캐시 서버 (Redis)
**역할**: 빠른 임시 저장소

- 포트 6379
- 중복 분석 방지
- 자주 사용하는 데이터 임시 저장

**비유**: 임시 보관함, 자주 찾는 물건을 여기다 두고 빠르게 가져감

---

### 1층: 데이터 저장소 (지하 창고)
**역할**: 모든 데이터의 최종 저장소

**Postgres (포트 5432)**:
- 메타데이터 저장
- 이벤트 기록
- 관계형 데이터

**DuckDB (파일 시스템)**:
- 시계열 데이터
- 대용량 분석 데이터
- 파일로 저장 (`data/analytics.db`)

**비유**: 지하 창고, 모든 물건을 영구 보관

---

## 🔄 실제 요청 흐름 (층계로)

### 시나리오: 사용자가 대시보드를 열 때

```
10층: 사용자 브라우저
  ↓ "http://EC2_IP:80 접속해줘"
  
9층: EC2 서버
  ↓ "포트 80으로 요청이 들어왔네"
  
8층: Docker Compose
  ↓ "web 컨테이너로 라우팅"
  
7층: Nginx (안내 데스크)
  ↓ "웹 요청이네? 5층 파일 제공"
  ↓ React 앱 전달
  
10층: 사용자 브라우저
  ↓ "React 앱 받았어, 이제 /api/live 요청해야지"
  ↓ fetch("/api/live")
  
7층: Nginx
  ↓ "/api/live 요청이네? 6층으로 안내해야겠다"
  ↓ proxy_pass http://api:8080
  
6층: API 서버
  ↓ "데이터 요청이네? 1층에서 가져와야겠다"
  ↓ DuckDB/Postgres 조회
  
1층: 데이터 저장소
  ↓ "데이터 찾았어!"
  ↓ JSON 데이터 반환
  
6층: API 서버
  ↓ "데이터 받았어, 사용자에게 전달하자"
  ↓ JSON 응답
  
7층: Nginx
  ↓ "응답 받았어, 사용자에게 전달하자"
  ↓ 응답 전달
  
10층: 사용자 브라우저
  ↓ "데이터 받았어! 화면에 표시하자"
  ✅ 완료!
```

---

## 🏗️ 층간 통신 방식

### 외부에서 접근 (10층 → 9층)
```
사용자 → EC2:포트번호
```
- 포트 매핑을 통해 접근
- 예: `EC2:8081` → `컨테이너:8080`

### Docker 네트워크 내부 통신 (층간 엘리베이터)
```
컨테이너명:포트번호
```
- 서비스 이름으로 직접 통신
- 예: `api:8080`, `postgres:5432`, `redis:6379`
- 포트 매핑과 무관하게 통신 가능

**비유**: 건물 내부 엘리베이터, 층간 이동은 서비스 이름으로

---

## 📊 포트 정리 (층별)

| 층 | 서비스 | 컨테이너 내부 | EC2 호스트 | 접근 방식 |
|---|--------|------------|-----------|----------|
| 7층 | Nginx | 80 | 80 | 외부 접근 가능 |
| 6층 | API | 8080 | 8081 | 외부 접근 가능 |
| 4층 | Agent API | 8000 | 8000 | 외부 접근 가능 |
| 5층 | Dashboard | 8501 | 8501 | 외부 접근 가능 |
| 2층 | Redis | 6379 | 6379 | 외부 접근 가능 |
| 1층 | Postgres | 5432 | 5432 | 외부 접근 가능 |
| 3층 | Collector | - | - | 내부만 |
| 3층 | Detector | - | - | 내부만 |
| 4층 | Agent Worker | - | - | 내부만 |

---

## 🎯 핵심 포인트

1. **10층(사용자)은 7층(Nginx)만 봄**
   - 사용자는 항상 포트 80으로 접속
   - Nginx가 내부적으로 다른 층으로 안내

2. **층간 통신은 서비스 이름 사용**
   - `api:8080`, `postgres:5432` 등
   - 포트 매핑과 무관

3. **일부 층은 외부 접근 불가**
   - Collector, Detector, Agent Worker
   - 내부 작업만 수행

4. **8층(Docker Compose)이 모든 층 관리**
   - 하나의 명령어로 모든 층 제어

---

**비유 요약**: 
- 10층 = 건물 밖 사람들
- 9층 = 건물 자체
- 8층 = 건물 관리실
- 7층 = 안내 데스크
- 6층 = 고객 서비스
- 5층 = 사용자 화면
- 4층 = AI 분석실
- 3층 = 자동 작업실
- 2층 = 임시 보관함
- 1층 = 지하 창고
